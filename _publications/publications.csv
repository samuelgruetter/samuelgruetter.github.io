"Key","Item Type","Publication Year","Author","Title","Publication Title","ISBN","ISSN","DOI","Url","Abstract Note","Date","Date Added","Date Modified","Access Date","Pages","Num Pages","Issue","Volume","Number Of Volumes","Journal Abbreviation","Short Title","Series","Series Number","Series Text","Series Title","Publisher","Place","Language","Rights","Type","Archive","Archive Location","Library Catalog","Call Number","Extra","Notes","File Attachments","Link Attachments","Manual Tags","Automatic Tags","Editor","Series Editor","Translator","Contributor","Attorney Agent","Book Author","Cast Member","Commenter","Composer","Cosponsor","Counsel","Interviewer","Producer","Recipient","Reviewed Author","Scriptwriter","Words By","Guest","Number","Edition","Running Time","Scale","Medium","Artwork Size","Filing Date","Application Number","Assignee","Issuing Authority","Country","Meeting Name","Conference Name","Court","References","Reporter","Legal Status","Priority Numbers","Programming Language","Version","System","Code","Code Number","Section","Session","Committee","History","Legislative Body"
"8RXMT8NZ","journalArticle","2024","Gruetter, Samuel; Bourgeat, Thomas; Chlipala, Adam","Verifying Software Emulation of an Unsupported Hardware Instruction","15th International Conference on Interactive Theorem Proving (ITP 2024)","","","10.4230/LIPIcs.ITP.2024.17","https://samuelgruetter.net/assets/softmul.pdf","","2024-09","2024-04-11 03:21:10","2024-09-11 14:39:56","","","","","309","","","","","","","","","","","","","","","","","Citation Key: softmul_ITP24 tex.code: https://github.com/mit-plv/softmul","","/home/sam/Zotero/storage/MT8P87GX/Gruetter et al. - 2024 - Verifying Software Emulation of an Unsupported Har.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"6E5BLZ4X","journalArticle","2024","Erbsen, Andres; Philipoom, Jade; Jamner, Dustin; Lin, Ashley; Gruetter, Samuel; Pit-Claudel, Clément; Chlipala, Adam","Foundational Integration Verification of a Cryptographic Server","Proceedings of the ACM on Programming Languages","","","10.1145/3656446","https://dl.acm.org/doi/pdf/10.1145/3656446","","2024-06","2024-04-11 02:53:47","2024-09-11 14:28:42","","","","PLDI","8","","","","","","","","","","","","","","","","","Citation Key: Garagedoor_PLDI24 tex.code: https://github.com/mit-plv/fiat-crypto/tree/GarageDoorPLDI24","","/home/sam/Zotero/storage/IFGLEWA5/Erbsen et al. - 2024 - Foundational Integration Verification of a Cryptog.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"3WIBR2R9","journalArticle","2024","Gruetter, Samuel; Fukala, Viktor; Chlipala, Adam","Live Verification in an Interactive Proof Assistant","Proceedings of the ACM on Programming Languages","","","10.1145/3656439","https://dl.acm.org/doi/pdf/10.1145/3656439","","2024-06","2024-04-11 02:49:53","2024-09-11 14:27:55","","","","PLDI","8","","","","","","","","","","","","","","","","","Citation Key: LiveVerif_PLDI24 tex.code: https://github.com/mit-plv/bedrock2/tree/LiveVerifArtifact","","/home/sam/Zotero/storage/Z898PRSU/Gruetter et al. - 2024 - Live Verification in an Interactive Proof Assistan.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"WPQJJJ78","journalArticle","2023","Bourgeat, Thomas; Clester, Ian; Erbsen, Andres; Gruetter, Samuel; Singh, Pratap; Wright, Andy; Chlipala, Adam","Flexible Instruction-Set Semantics via Abstract Monads (Experience Report)","Proceedings of the ACM on Programming Languages","","","10.1145/3607833","https://dl.acm.org/doi/10.1145/3607833","Instruction sets, from families like x86 and ARM, are at the center of many ambitious formal-methods projects. Many verification, synthesis, programming, and debugging tools rely on formal semantics of instruction sets, but different tools can use semantics in rather different ways. The best-known work applying single semantics across diverse tools relies on domain-specific languages like Sail, where the language and its translation tools are specialized to the realm of instruction sets. In the context of the open RISC-V instruction-set family, we decided to explore a different approach, with semantics written in a carefully chosen subset of Haskell. This style does not depend on any new language translators, relying instead on parameterization of semantics over type-class instances. We have used a single core semantics to support testing, interactive proof, and model checking of both software and hardware, demonstrating that monads and the ability to abstract over them using type classes can support pleasant prototyping of ISA semantics.","2023-08-31","2024-03-02 16:39:10","2025-01-07 14:20:18","2024-03-02 16:39:10","","","ICFP","7","","Proc. ACM Program. Lang.","","","","","","","","","","","","","ACM Digital Library","","Citation Key: RiscVSpec_ICFP23 tex.code: https://github.com/mit-plv/riscv-semantics","","/home/sam/Zotero/storage/A2FLKCMK/Bourgeat et al. - 2023 - Flexible Instruction-Set Semantics via Abstract Mo.pdf","","","instruction-set semantics; interactive proof assistants; type classes","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"MTL84ATS","journalArticle","2023","Charguéraud, Arthur; Chlipala, Adam; Erbsen, Andres; Gruetter, Samuel","Omnisemantics: Smooth Handling of Nondeterminism","ACM Transactions on Programming Languages and Systems","","0164-0925","10.1145/3579834","https://dl.acm.org/doi/10.1145/3579834","This article gives an in-depth presentation of the omni-big-step and omni-small-step styles of semantic judgments. These styles describe operational semantics by relating starting states to sets of outcomes rather than to individual outcomes. A single derivation of these semantics for a particular starting state and program describes all possible nondeterministic executions (hence the name omni), whereas in traditional small-step and big-step semantics, each derivation only talks about one single execution. This restructuring allows for straightforward modeling of both nondeterminism and undefined behavior as commonly encountered in sequential functional and imperative programs. Specifically, omnisemantics inherently assert safety (i.e., they guarantee that none of the execution branches gets stuck), while traditional semantics need either a separate judgment or additional error markers to specify safety in the presence of nondeterminism. Omnisemantics can be understood as an inductively defined weakest-precondition semantics (or more generally, predicate-transformer semantics) that does not involve invariants for loops and recursion but instead uses unrolling rules like in traditional small-step and big-step semantics. Omnisemantics were previously described in association with several projects, but we believe the technique has been underappreciated and deserves a well-motivated, extensive, and pedagogical presentation of its benefits. We also explore several novel aspects associated with these semantics, in particular, their use in type-safety proofs for lambda calculi, partial-correctness reasoning, and forward proofs of compiler correctness for terminating but potentially nondeterministic programs being compiled to nondeterministic target languages. All results in this article are formalized in Coq.","2023-03-08","2023-08-15 18:31:37","2024-09-11 14:29:58","2023-08-15 18:31:37","","","1","45","","ACM Trans. Program. Lang. Syst.","Omnisemantics","","","","","","","","","","","","ACM Digital Library","","Citation Key: Omnisemantics_TOPLAS23 tex.code: https://samuelgruetter.net/assets/omnisemantics-artifact.zip","","/home/sam/Zotero/storage/VKGYRANY/Charguéraud et al. - 2023 - Omnisemantics Smooth Handling of Nondeterminism.pdf","","","termination; Nondeterminism; compiler correctness proofs","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"IKW78EMF","journalArticle","2021","Erbsen, Andres; Gruetter, Samuel; Choi, Joonwon; Wood, Clark; Chlipala, Adam","Integration Verification Across Software and Hardware for a Simple Embedded System","PLDI 2021: Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation","","","10.1145/3453483.3454065","https://samuelgruetter.net/assets/lightbulb_pldi21.pdf","The interfaces between layers of a system are susceptible to bugs if developers of adjacent layers proceed under subtly different assumptions. Formal verification of two layers against the same formal model of the interface between them can be used to shake out these bugs. Doing so for every interface in the system can, in principle, yield unparalleled assurance of the correctness and security of the system as a whole. However, there have been remarkably few efforts that carry out this exercise, and all of them have simplified the task by restricting interactivity of the application, inventing new simplified instruction sets, and using unrealistic input and output mechanisms. We report on the first verification of a realistic embedded system, with its application software, device drivers, compiler, and RISC-V processor represented inside the Coq proof assistant as one mathematical object, with a machine-checked proof of functional correctness. A key challenge is structuring the proof modularly, so that further refinement of the components or expansion of the system can proceed without revisiting the rest of the system.","2021-06","2021-06-02 14:11:58","2025-01-07 14:18:09","","","","","","","","","","","","","","","","","","","","","","Citation Key: Lightbulb_PLDI21 tex.code: https://github.com/mit-plv/bedrock2/blob/lightbulb_artifact/ArtifactEvaluation.md","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"XWDYKXTA","journalArticle","2018","Cao, Qinxiang; Beringer, Lennart; Gruetter, Samuel; Dodds, Josiah; Appel, Andrew W.","VST-Floyd: A Separation Logic Tool to Verify Correctness of C Programs","Journal of Automated Reasoning","","0168-7433, 1573-0670","10.1007/s10817-018-9457-5","http://www.cs.princeton.edu/~appel/papers/VST-Floyd.pdf","The Veriﬁed Software Toolchain builds foundational machine-checked proofs of the functional correctness of C programs. Its program logic, Veriﬁable C, is a shallowly embedded higher-order separation Hoare logic which is proved sound in Coq with respect to the operational semantics of CompCert C light. This paper introduces VST-Floyd, a veriﬁcation assistant which offers a set of semiautomatic tactics helping users build functional correctness proofs for C programs using Veriﬁable C.","2018-06","2018-07-12 15:49:47","2024-09-11 14:32:10","2018-07-12 15:49:47","","","1-4","61","","","VST-Floyd","","","","","","","en","","","","","Crossref","","Citation Key: VSTFloyd_JAR18 tex.code: https://github.com/PrincetonUniversity/VST","","/home/sam/Documents/Dropbox/ebooks/ZotFile/Cao et al 2018 VST-Floyd - A Separation Logic Tool to Verify Correctness of C Programs.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"7QZE4QF2","journalArticle","2017","Gruetter, Samuel; Murray, Toby","Short Paper: Towards Information Flow Reasoning about Real-World C Code","PLAS '17: Proceedings of the 2017 Workshop on Programming Languages and Analysis for Security","","","10.1145/3139337.3139345","https://people.eng.unimelb.edu.au/tobym/papers/plas2017.pdf","Strangely, despite much recent success proving information flow control (IFC) security for C programs, little work has investigated how to prove IFC security directly against C code, as opposed to over an abstract specification. We consider what a suitable IFC logic for C might look like, and propose a suitable continuation-passing style IFC security definition for C code. We discuss our ongoing work implementing these ideas in the context of an existing full-featured, sound program verification framework for C, the Verified Software Toolchain, supported by the verified C complier CompCert.","2017-10","2018-11-28 17:56:28","2025-01-07 14:18:35","2018-11-28 17:56:28","","","","","","","Short Paper","","","","","","","en","","","","","Crossref","","Citation Key: VSTFlow_PLAS17 tex.code: https://github.com/samuelgruetter/vst-ifc","","/home/sam/Documents/Dropbox/ebooks/ZotFile/Gruetter Murray 2017 Short Paper - Towards Information Flow Reasoning about Real-World C Code.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"BB5G9AWC","journalArticle","2016","Gruetter, Samuel; Graf, Daniel; Schmid, Benjamin","Watch them Fight! Creativity Task Tournaments of the Swiss Olympiad in Informatics","Olympiads in Informatics","","18227732, 23358955","10.15388/ioi.2016.05","http://www.ioinformatics.org/oi/pdf/v10_2016_73_85.pdf","As part of the qualification process for the Swiss Olympiad in Informatics, the contestants are each year confronted with one “Creativity Task”. Unlike typical problems in programming competitions, creativity tasks usually do not have an optimal solution, and are often adaptations of popular board or computer games. After receiving all submissions, a tournament is organized, where the students can watch how their programs play interactively against each other, and points are awarded to the authors according to the tournament ranking.","2016-07-10","2018-11-28 17:22:36","2025-01-07 14:19:05","2018-11-28 17:22:36","","","1","10","","","","","","","","","","en","","","","","Crossref","","Citation Key: Creativity_IOI16 tex.code: https://dgraf.ch/soi/creativity/","","/home/sam/Documents/Dropbox/ebooks/ZotFile/Gruetter Graf Schmid 2016 Watch them Fight! Creativity Task Tournaments of the Swiss Olympiad in.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"HUJBFNZJ","journalArticle","2016","Amin, Nada; Gruetter, Samuel; Odersky, Martin; Rompf, Tiark; Stucki, Sandro","The Essence of Dependent Object Types","A List of Successes That Can Change the World: Essays Dedicated to Philip Wadler on the Occasion of His 60th Birthday (WadlerFest)","","","10.1007/978-3-319-30936-1_14","https://infoscience.epfl.ch/record/215280/files/paper_1.pdf","Focusing on path-dependent types, the paper develops foundations for Scala from first principles. Starting from a simple calculus D-<: of dependent functions, it adds records, intersections and recursion to arrive at DOT, a calculus for dependent object types. The paper shows an encoding of System F with subtyping in D-<: and demonstrates the expressiveness of DOT by modeling a range of Scala constructs in it.","2016-03","2018-11-28 17:16:24","2025-01-07 14:12:04","2018-11-28 17:16:24","","","Lecture Notes in Computer Science LNTCS, volume 9600","","","","","","","","","","","en","","","","","infoscience.epfl.ch","","Citation Key: DOT_WF16 tex.code: https://github.com/samuelgruetter/dot-calculus/blob/master/dev/lf/doc.md","","/home/sam/Documents/Dropbox/ebooks/ZotFile/Amin et al 2016 The Essence of Dependent Object Types2.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""